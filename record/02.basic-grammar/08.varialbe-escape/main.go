package main

import "fmt"

/*
变量逃逸分析

栈: 一种拥有特殊规则的线性表数据结构
1. 栈只允许从线性表的同一段放入和取出数据
2. 按照先进后出的顺序出入栈


堆:
堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。
经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，
但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化

堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。


变量逃逸（Escape Analysis）——自动决定变量分配方式，提高运行效率
通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。


编译器觉得变量应该分配在堆和栈上的原则是：
1. 变量是否被取地址；
2. 变量是否发生逃逸。


*/


func main(){
	// stackExample();

	// go run -gcflags "-m -l" main.go
	// 声明a变量并打印
    var a int
    // 调用void()函数
    void()
    // 打印a变量的值和dummy()函数返回
    fmt.Println(a, dummy(0))
}


/*
函数stackExample运行时,会进行变量 a,b,c,x 的内存分配(栈)
函数退出时,变量a,b,c,x 的栈内存再出栈释放内存,整个分配过程通过栈的分配和回收非常迅速

*/
func stackExample() int{
	// 声明变量 a和 b
	var a,b = 10,20;
	// 声明变量 c
	var c int;
	// 赋值变量 c 为变量 a 和 b 的积
	c = a*b;

	// 声明变量 x
	var x int;
	// 赋值变量 x 为变量 c 和 10 的积
	x = c *10;

	// 返回变量 x
	return x;
}


func dummy(b int) int {
    // 声明一个变量c并赋值
    var c int
    c = b
    return c
}
// 空函数, 什么也不做
func void() {}